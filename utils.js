const archiver = require('archiver');
const { ObjectId } = require('mongodb');

const fs = require('fs');

function progressBar(progress) {
    const barLength = 50;
    const filledLength = Math.round(barLength * progress);
    const emptyLength = barLength - filledLength;
    const progressBar = '█'.repeat(filledLength) + '░'.repeat(emptyLength);
    return `[${progressBar}] ${Math.round(progress * 100)}%`;  
}

// The zipFolder function has been generated by GPT 3.5
function zipFolder(sourceFolder, targetZip) {
    return new Promise((resolve, reject) => {
        const output = fs.createWriteStream(targetZip);
        const archive = archiver('zip', {
            zlib: { level: 9 } 
        });
        archive.pipe(output);
        archive.directory(sourceFolder, false);
        archive.finalize();
        output.on('close', () => {
            console.log(`Folder "${sourceFolder}" has been zipped to "${targetZip}"`);
            resolve();
        });
        archive.on('error', (err) => {
            reject(`Error zipping folder: ${err}`);
        });
    });
}

function removeHTML(content){
    return content === undefined  ? 'N/A' : content.replace(/<\/?[^>]+(>|$)/g,'');
}

async function findImages(auditName, title, content, db){
    if(content === undefined) return content;
    const imgRegex = /<img.*?src=['"](.*?)['"].*?alt=['"](.*?)['"].*?>/g;
    let match;
    const imgcollection = db.collection('images');
    let count = 1;
    while((match = imgRegex.exec(content)) !== null){
        if(!fs.existsSync(`${auditName}/${title}`)){
            fs.mkdirSync(`${auditName}/${title}`);
        }
        let document = await imgcollection.findOne({_id:new ObjectId(match[1])});
        console.log('0'.repeat((3 - Math.abs(count).toString().length)));
        content = content.replace(match[0], ` (Proof_${'0'.repeat((3 - Math.abs(count).toString().length))}${count} - ${match[2]}) `);
        const imageData = document.value.split(';base64,').pop();
        const extension = document.value.substring(document.value.indexOf('/') + 1, document.value.indexOf(';'));
        fs.writeFile(`${auditName}/${title}/Proof_${'0'.repeat((3 - Math.abs(count).toString().length))}${count}.${extension}`,imageData,{encoding:'base64'},(err) => {});
        count++;
    }
    return removeHTML(content);
}

const cleanCVSS = (cvss) => {
    let output = "";
    // Dictionnaries generated by GPT3.5
    const abbreviationDictionary = {AV: "Attack Vector", AC: "Attack Complexity", PR: "Privileges Required", UI: "User Interaction", S: "Scope", C: "Confidentiality", I: "Integrity", A: "Availability"};
    const cvssDictionary = {AV: {N: "Network", A: "Adjacent Network", L: "Local", P: "Physical"}, AC: {H: "High", L: "Low"}, PR: {N: "None", L: "Low", H: "High"}, UI: {N: "None", R: "Required"}, S: {U: "Unchanged", C: "Changed"}, C: {N: "None", L: "Low", H: "High"}, I: {N: "None", L: "Low", H: "High"}, A: {N: "None", L: "Low", H: "High"}};
    const cvssArray = cvss.split('CVSS:3.1/')[1].split('/');
    for (let index = 0; index < 4; index++) {
        output += `${abbreviationDictionary[cvssArray[index].split(":")[0]]}:\t\t ${cvssDictionary[cvssArray[index].split(":")[0]][cvssArray[index].split(":")[1]]}\t${abbreviationDictionary[cvssArray[index+4].split(":")[0]]}:\t\t ${cvssDictionary[cvssArray[index+4].split(":")[0]][cvssArray[index+4].split(":")[1]]}\n`;
    }
    return output;
}

module.exports = {progressBar, zipFolder, findImages, cleanCVSS, removeHTML}